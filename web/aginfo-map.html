<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AgInfo Map</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />

  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    #filter-control {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 2000;
      background: white;
      padding: 12px;
      border-radius: 5px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      font-family: Arial, sans-serif;
      font-size: 14px;
      min-width: 220px;
    }
    #filter-control label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    #filter-control select {
      width: 200px;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div id="filter-control">
    <div style="margin-bottom: 10px;">
      <a href="aginfo-network-map.html" style="color: #0066cc; text-decoration: none; font-weight: bold; display: block; margin-bottom: 5px;">üîó Network Map</a>
      <a href="aginfo-starburst.html" style="color: #0066cc; text-decoration: none; font-weight: bold; display: block;">üìä Starburst Chart</a>
    </div>
    <label for="facility-type-filter">Filter by Facility Type:</label>
    <select id="facility-type-filter">
      <option value="">All Types</option>
      <option value="Agronomy Center">Agronomy Center</option>
      <option value="Ethanol Plant">Ethanol Plant</option>
      <option value="Farm Supply Store">Farm Supply Store</option>
      <option value="Feedlot">Feedlot</option>
      <option value="Fertilizer Plant">Fertilizer Plant</option>
      <option value="Fuel Station">Fuel Station</option>
      <option value="Grain Elevator">Grain Elevator</option>
      <option value="Seed & Feed Mill">Seed & Feed Mill</option>
      <option value="Service Station">Service Station</option>
    </select>
  </div>
  <div id="map"></div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    crossorigin=""
  ></script>

  <script>
    // --- CONFIG SECTION: change these values as needed ---

    // Dynamically detect host from current page URL
    // This uses the same host as the web page, so it works with any IP
    const currentHost = window.location.hostname;
    const GEOSERVER_PORT = 8090; // GeoServer port from docker-compose.yml
    const GEOSERVER_URL = `http://${currentHost}:${GEOSERVER_PORT}/geoserver`;

    // Workspace:name of your WMS layer (e.g. aginfo:facility)
    const WMS_LAYER_NAME = "aginfo:facility";

    // Initial map center (Kansas) and zoom
    const INITIAL_CENTER = [38.5, -98.5]; // [lat, lon]
    const INITIAL_ZOOM = 7;


    // --- MAP SETUP ---
    
    // Wait for DOM to be ready
    let map;
    let osm;
    
    // Function to wait for Leaflet to load
    function waitForLeaflet(callback, maxAttempts = 20) {
      let attempts = 0;
      const checkInterval = setInterval(function() {
        attempts++;
        console.log(`Checking for Leaflet... attempt ${attempts}`);
        
        if (typeof L !== 'undefined') {
          console.log('Leaflet is now available!');
          clearInterval(checkInterval);
          callback();
        } else if (attempts >= maxAttempts) {
          console.error('Leaflet failed to load after', maxAttempts, 'attempts');
          clearInterval(checkInterval);
          alert('Error: Leaflet map library failed to load. Please check your internet connection and refresh the page.');
        }
      }, 200); // Check every 200ms
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM loaded, waiting for Leaflet...');
        
        // Ensure map container is visible and has dimensions
        const mapContainer = document.getElementById('map');
        if (mapContainer) {
            // Force a reflow to ensure container is rendered
            mapContainer.offsetHeight;
        }
        
        // Wait for Leaflet to be available
        waitForLeaflet(function() {
            // Small delay to ensure container is fully rendered
            setTimeout(function() {
                initializeMap();
            }, 50);
        });
    });
    
    function initializeMap() {
        console.log('Initializing map...');

        // Create the map
        try {
            map = L.map("map", {
                preferCanvas: false
            }).setView(INITIAL_CENTER, INITIAL_ZOOM);

            // OSM base layer
            osm = L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
                maxZoom: 19,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Invalidate size to ensure proper rendering
            setTimeout(function() {
                if (map) {
                    map.invalidateSize();
                }
            }, 100);

            // Handle window resize
            window.addEventListener('resize', function() {
                if (map) {
                    setTimeout(function() {
                        map.invalidateSize();
                    }, 100);
                }
            });

            // Load facilities when map is ready
            map.whenReady(async function() {
                console.log('Map initialized');
                console.log('GeoServer URL:', GEOSERVER_URL);
                // Load lookups first, then facilities
                await loadLookupsFromGeoServer();
                console.log('Loading facilities from GeoServer WFS...');
                loadFacilities();
            });
            
            // Add filter change event listener
            const filterSelect = document.getElementById('facility-type-filter');
            if (filterSelect) {
                filterSelect.addEventListener('change', function() {
                    const selectedType = this.value;
                    console.log('Filter changed to:', selectedType || 'All Types');
                    currentFilter = selectedType;
                    loadFacilities(selectedType);
                });
            }
        } catch (error) {
            console.error('Error creating map:', error);
            alert('Error initializing map: ' + error.message);
        }
    }

    // HTML escaping function to prevent XSS vulnerabilities
    function escapeHtml(text) {
        if (text == null) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Store markers for potential cleanup
    let facilityMarkers = [];
    
    // Current filter value
    let currentFilter = '';
    
    // Lookups for facility types and companies (fallback only - names should come from GeoServer view)
    let facilityTypeLookups = {};
    let companyLookups = {};
    
    // Load company and facility type lookups from database via GeoServer SQL view
    // The facility layer should use facility_with_names view which includes company_name and facility_type_name
    // This function is kept for fallback, but ideally names come directly from the GeoServer view
    async function loadLookupsFromGeoServer() {
        // Names should come directly from facility_with_names view via GeoServer
        // This is just a placeholder for potential fallback scenarios
        console.log('Using company_name and facility_type_name directly from GeoServer view');
    }
    
    // Function to load facilities dynamically from GeoServer WFS
    async function loadFacilities(filterType = '') {
        try {
            // Build WFS GetFeature request URL
            let wfsUrl = `${GEOSERVER_URL}/wfs?` +
                `service=WFS&` +
                `version=1.1.0&` +
                `request=GetFeature&` +
                `typeName=${WMS_LAYER_NAME}&` +
                `outputFormat=application/json&` +
                `srsName=EPSG:4326`;
            
            // Note: CQL filter removed - facility_type_name is not in the GeoServer layer
            // We'll do client-side filtering instead, which is more reliable
            // The WFS layer only exposes facility_type_id, not facility_type_name

            console.log('Fetching facilities from:', wfsUrl);
            
            const response = await fetch(wfsUrl);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            // Check if response is actually JSON
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
                // If not JSON, get text to see what we got
                const text = await response.text();
                console.error('Response is not JSON:', text.substring(0, 200));
                throw new Error('Server returned non-JSON response. The filter may not be supported. Try "All Types".');
            }
            
            const geojson = await response.json();
            
            // Check if response is an error
            if (geojson.error || geojson.exception) {
                console.error('GeoServer error:', geojson);
                throw new Error(geojson.error?.message || geojson.exception || 'GeoServer returned an error');
            }
            
            // Clear existing markers
            if (map) {
                facilityMarkers.forEach(marker => map.removeLayer(marker));
            }
            facilityMarkers = [];
            
            // Process GeoJSON features
            if (geojson.features && geojson.features.length > 0) {
                geojson.features.forEach(feature => {
                    // Skip features with null or missing geometry
                    if (!feature.geometry || !feature.geometry.coordinates) {
                        console.warn('Skipping feature with missing geometry:', feature);
                        return;
                    }
                    
                    const coords = feature.geometry.coordinates; // [lng, lat] in GeoJSON
                    
                    // Validate coordinates array has at least 2 elements (lng, lat)
                    if (!Array.isArray(coords) || coords.length < 2 || 
                        typeof coords[0] !== 'number' || typeof coords[1] !== 'number') {
                        console.warn('Skipping feature with invalid coordinates:', feature);
                        return;
                    }
                    
                    const props = feature.properties;
                    
                    // Get facility type name directly from GeoServer (from SQL view)
                    // Try facility_type_name first (from view), then fallback to lookup
                    const facilityType = props.facility_type_name || 
                                       (props.facility_type_id ? 
                                        (facilityTypeLookups[props.facility_type_id] || 
                                         facilityTypeLookups[String(props.facility_type_id)] ||
                                         `Type ${props.facility_type_id}`) : null);
                    
                    // Get company name directly from GeoServer (from SQL view)
                    // Try company_name first (from view), then fallback to lookup
                    const companyName = props.company_name || 
                                      (props.company_id ? 
                                       (companyLookups[props.company_id] || 
                                        companyLookups[String(props.company_id)] ||
                                        companyLookups[parseInt(props.company_id)] ||
                                        `Company ${props.company_id}`) : null);
                    
                    // Debug: log first feature to see available properties
                    if (facilityMarkers.length === 0 && geojson.features.length > 0) {
                        console.log('Sample feature properties:', Object.keys(props));
                        console.log('Facility type ID:', facilityTypeId);
                        console.log('Company ID:', companyId);
                    }
                    
                    // Client-side filtering by facility type name
                    if (filterType && filterType !== '' && facilityType !== filterType) {
                        return;
                    }
                    
                    // Get facility website URL from GeoServer
                    const facilityWebsite = props.website_url || null;
                    let facilityWebsiteLink = '';
                    if (facilityWebsite && facilityWebsite.trim() !== '') {
                        let websiteUrl = facilityWebsite.trim();
                        if (!websiteUrl.match(/^https?:\/\//i)) {
                            websiteUrl = 'https://' + websiteUrl;
                        }
                        facilityWebsiteLink = `<br><small><a href="${escapeHtml(websiteUrl)}" target="_blank" style="color: #0066cc; text-decoration: none;">üåê Website</a></small>`;
                    }
                    
                    // Build popup content with escaped HTML to prevent XSS
                    const popupContent = `
                        <b>${escapeHtml(props.name || 'Unknown')}</b><br>
                        ${escapeHtml(props.city || '')}, ${escapeHtml(props.state || '')}<br>
                        ${escapeHtml(props.address_line1 || '')}
                        ${facilityType ? '<br><small>Type: ' + escapeHtml(facilityType) + '</small>' : ''}
                        ${companyName ? '<br><small>Company: ' + escapeHtml(companyName) + '</small>' : ''}
                        ${props.description ? '<br><small>' + escapeHtml(props.description) + '</small>' : ''}
                        ${facilityWebsiteLink}
                    `;
                    
                    // Create marker (note: GeoJSON uses [lng, lat], Leaflet uses [lat, lng])
                    if (map) {
                        const marker = L.marker([coords[1], coords[0]])
                            .addTo(map)
                            .bindPopup(popupContent);
                        
                        facilityMarkers.push(marker);
                    }
                });
                
                console.log(`Loaded ${facilityMarkers.length} facilities from database`);
                
                // Fit map to show all facilities
                if (map && facilityMarkers.length > 0) {
                    const group = new L.featureGroup(facilityMarkers);
                    map.fitBounds(group.getBounds().pad(0.1));
                }
            } else {
                console.warn('No facilities found in database');
            }
        } catch (error) {
            console.error('Error loading facilities:', error);
            // Show error message to user (with escaped HTML to prevent XSS)
            if (map) {
                L.popup()
                    .setLatLng([38.5, -99.5])
                    .setContent(`<b>Error loading facilities</b><br>${escapeHtml(error.message)}<br><small>Check console for details</small>`)
                    .openOn(map);
            }
        }
    }
    

    // Optional: Layer control (removed since we're using dynamic markers now)
  </script>
</body>
</html>
