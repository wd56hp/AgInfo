<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>AgInfo Starburst Map - By Company</title>
  
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 10px;
    }
    
    .subtitle {
      text-align: center;
      color: #666;
      margin-bottom: 30px;
    }
    
    #chart-container {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 600px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      margin: 20px auto;
      max-width: 1200px;
      position: relative;
    }
    
    #starburst {
      width: 100%;
      height: 100%;
    }
    
    .tooltip {
      position: absolute;
      padding: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      border-radius: 4px;
      pointer-events: none;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 1000;
    }
    
    .tooltip.visible {
      opacity: 1;
    }
    
    .legend {
      position: absolute;
      top: 20px;
      right: 20px;
      background: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      font-size: 12px;
      max-width: 200px;
    }
    
    .legend h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #333;
    }
    
    .legend-item {
      margin: 5px 0;
      display: flex;
      align-items: center;
    }
    
    .legend-color {
      width: 16px;
      height: 16px;
      margin-right: 8px;
      border-radius: 3px;
    }
    
    .loading {
      text-align: center;
      padding: 50px;
      color: #666;
    }
    
    .error {
      text-align: center;
      padding: 50px;
      color: #d32f2f;
    }
    
    .info-panel {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      font-size: 12px;
      max-width: 250px;
    }
    
    .info-panel h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #333;
    }
    
    .filter-control {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 1000;
    }
    
    .filter-header {
      background: white;
      padding: 10px 15px;
      border-radius: 5px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      font-size: 14px;
      font-weight: bold;
      color: #333;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      min-width: 150px;
      transition: background-color 0.2s;
    }
    
    .filter-header:hover {
      background: #f5f5f5;
    }
    
    .filter-header::after {
      content: '‚ñº';
      font-size: 10px;
      margin-left: 10px;
      transition: transform 0.2s;
    }
    
    .filter-control.expanded .filter-header::after {
      transform: rotate(180deg);
    }
    
    .filter-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 5px;
      background: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-size: 12px;
      max-height: 400px;
      overflow-y: auto;
      min-width: 250px;
      max-width: 300px;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: opacity 0.2s, visibility 0.2s, transform 0.2s;
      pointer-events: none;
    }
    
    .filter-control:hover .filter-dropdown,
    .filter-control.expanded .filter-dropdown {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
      pointer-events: auto;
    }
    
    .filter-dropdown .select-all {
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid #ddd;
    }
    
    .filter-dropdown .company-list {
      max-height: 300px;
      overflow-y: auto;
    }
    
    .filter-dropdown .company-item {
      margin: 5px 0;
      display: flex;
      align-items: center;
    }
    
    .filter-dropdown .company-item input[type="checkbox"] {
      margin-right: 8px;
      cursor: pointer;
    }
    
    .filter-dropdown .company-item label {
      cursor: pointer;
      flex: 1;
      user-select: none;
    }
    #version-display {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 5px 10px;
      border-radius: 3px;
      font-size: 11px;
      color: #666;
      font-family: Arial, sans-serif;
      z-index: 1500;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <h1>AgInfo Starburst Chart</h1>
  <div class="subtitle">Facilities grouped by Company and Facility Type</div>
  <div style="text-align: center; margin-bottom: 20px;">
    <a href="aginfo-map.html" style="color: #0066cc; text-decoration: none; margin: 0 10px;">üìç Standard Map</a>
    <a href="aginfo-network-map.html" style="color: #0066cc; text-decoration: none; margin: 0 10px;">üîó Network Map</a>
  </div>
  
  <div id="chart-container">
    <div id="starburst"></div>
    <div class="tooltip" id="tooltip"></div>
    <div class="filter-control" id="filter-control">
      <div class="filter-header" id="filter-header">
        <span>Filter by Company</span>
      </div>
      <div class="filter-dropdown" id="filter-dropdown">
        <div class="select-all">
          <label>
            <input type="checkbox" id="select-all-companies" checked>
            <strong>Select All</strong>
          </label>
        </div>
        <div class="company-list" id="company-list">
          <!-- Companies will be populated here -->
        </div>
      </div>
    </div>
    <div class="legend" id="legend">
      <h3>Legend</h3>
      <div id="legend-content"></div>
    </div>
    <div class="info-panel" id="info-panel">
      <h3>Info</h3>
      <div id="info-content">Click on a segment to see details</div>
    </div>
  </div>
  <div id="version-display"></div>

  <!-- Version info -->
  <script src="js/version.js"></script>
  
  <!-- D3.js library -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <script>
    // --- CONFIG SECTION: change these values as needed ---
    
    const currentHost = window.location.hostname;
    const GEOSERVER_PORT = 8090;
    const GEOSERVER_URL = `http://${currentHost}:${GEOSERVER_PORT}/geoserver`;
    // Using facility_with_names view for complete data with company and facility type names
    const WMS_LAYER_NAME = "aginfo:facility_with_names";
    
    // Chart dimensions
    const width = 800;
    const height = 800;
    const radius = Math.min(width, height) / 2 - 40;
    
    // Color schemes - D3 v7 doesn't have schemeCategory20, so we create an extended palette
    const extendedCompanyColors = [
      ...d3.schemeCategory10,
      ...d3.schemeSet2,
      ...d3.schemeSet1,
      ...d3.schemePastel2,
      ...d3.schemeSet3
    ];
    
    const colorSchemes = {
      company: d3.scaleOrdinal(extendedCompanyColors),
      facilityType: d3.scaleOrdinal(d3.schemeSet3),
      default: d3.scaleOrdinal(d3.schemePastel1)
    };
    
    // --- GLOBAL VARIABLES ---
    let data = null;
    let allData = null; // Store unfiltered data
    let root = null;
    let partition = null;
    let arc = null;
    let svg = null;
    let g = null;
    let selectedCompanies = new Set(); // Current filter selection (multiple companies)
    
    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', function() {
      // Display version
      if (typeof APP_VERSION !== 'undefined') {
        document.getElementById('version-display').textContent = 'v' + APP_VERSION;
      }
      
      console.log('Initializing starburst map...');
      initializeChart();
      loadFacilities();
    });
    
    // --- CHART INITIALIZATION ---
    function initializeChart() {
      // Create SVG
      svg = d3.select("#starburst")
        .append("svg")
        .attr("width", width)
        .attr("height", height);
      
      g = svg.append("g")
        .attr("transform", `translate(${width / 2}, ${height / 2})`);
      
      // Create partition layout
      partition = d3.partition()
        .size([2 * Math.PI, radius]);
      
      // Create arc generator
      arc = d3.arc()
        .startAngle(d => d.x0)
        .endAngle(d => d.x1)
        .innerRadius(d => d.y0)
        .outerRadius(d => d.y1)
        .padAngle(0.01)
        .padRadius(radius);
    }
    
    // --- DATA LOADING ---
    async function loadFacilities() {
      try {
        showLoading();
        
        // First, try to fetch company and facility type lookups
        const lookups = await fetchLookups();
        
        // Build WFS GetFeature request URL (without propertyName to get all fields)
        let wfsUrl = `${GEOSERVER_URL}/wfs?` +
          `service=WFS&` +
          `version=1.1.0&` +
          `request=GetFeature&` +
          `typeName=${WMS_LAYER_NAME}&` +
          `outputFormat=application/json&` +
          `srsName=EPSG:4326`;
        
        console.log('Fetching facilities from:', wfsUrl);
        
        const response = await fetch(wfsUrl);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const geojson = await response.json();
        console.log('Loaded GeoJSON:', geojson);
        
        // Log first feature to see available properties
        if (geojson.features && geojson.features.length > 0) {
          console.log('Sample feature properties:', Object.keys(geojson.features[0].properties));
          console.log('Sample feature:', geojson.features[0].properties);
        }
        
        // Process data with lookups
        allData = processData(geojson, lookups);
        console.log('Processed data:', allData);
        
        // If no company data, try alternative grouping
        if (allData.totalFacilities > 0 && Object.keys(allData.companies).length === 0) {
          console.warn('No company data found, grouping by facility type only');
          allData = processDataByType(geojson, lookups);
        }
        
        // Check if we have data
        if (!allData || allData.totalFacilities === 0) {
          throw new Error('No facilities found in the database');
        }
        
        if (Object.keys(allData.companies).length === 0) {
          throw new Error('No company data found. Check if facilities have company_id values.');
        }
        
        // Populate company filter checkboxes
        populateCompanyFilter(allData);
        
        // Apply initial filter (all companies selected)
        applyFilter(new Set(Object.keys(allData.companies)));
        
        // Set up filter event listeners
        setupFilterListeners();
        
      } catch (error) {
        console.error('Error loading facilities:', error);
        showError(error.message);
      }
    }
    
    // --- FETCH LOOKUPS ---
    async function fetchLookups() {
      const lookups = {
        companies: {},
        facilityTypes: {}
      };
      
      try {
        // First, try to fetch from local JSON file (fastest and most reliable)
        try {
          const lookupUrl = './data/lookups.json';
          const lookupResponse = await fetch(lookupUrl);
          if (lookupResponse.ok) {
            const lookupData = await lookupResponse.json();
            if (lookupData.companies) {
              // Convert string keys to numbers for matching
              Object.keys(lookupData.companies).forEach(key => {
                lookups.companies[parseInt(key)] = lookupData.companies[key];
                lookups.companies[key] = lookupData.companies[key]; // Also keep as string for flexibility
              });
            }
            if (lookupData.facilityTypes) {
              Object.keys(lookupData.facilityTypes).forEach(key => {
                lookups.facilityTypes[parseInt(key)] = lookupData.facilityTypes[key];
                lookups.facilityTypes[key] = lookupData.facilityTypes[key]; // Also keep as string
              });
            }
            console.log('Loaded lookups from JSON file:', lookups);
            return lookups;
          }
        } catch (e) {
          console.warn('Could not fetch lookup JSON file:', e);
        }
        
        // Fallback: Try to get company data via WFS if available
        try {
          const companyUrl = `${GEOSERVER_URL}/wfs?service=WFS&version=1.1.0&request=GetFeature&typeName=aginfo:company&outputFormat=application/json&maxFeatures=1000`;
          const companyResponse = await fetch(companyUrl);
          if (companyResponse.ok) {
            const companyData = await companyResponse.json();
            if (companyData.features) {
              companyData.features.forEach(f => {
                if (f.properties.company_id && f.properties.name) {
                  lookups.companies[f.properties.company_id] = f.properties.name;
                }
              });
            }
          }
        } catch (e) {
          console.warn('Could not fetch company lookup via WFS:', e);
        }
        
        // Fallback: Try to get facility_type data via WFS if available
        try {
          const typeUrl = `${GEOSERVER_URL}/wfs?service=WFS&version=1.1.0&request=GetFeature&typeName=aginfo:facility_type&outputFormat=application/json&maxFeatures=1000`;
          const typeResponse = await fetch(typeUrl);
          if (typeResponse.ok) {
            const typeData = await typeResponse.json();
            if (typeData.features) {
              typeData.features.forEach(f => {
                if (f.properties.facility_type_id && f.properties.name) {
                  lookups.facilityTypes[f.properties.facility_type_id] = f.properties.name;
                }
              });
            }
          }
        } catch (e) {
          console.warn('Could not fetch facility type lookup via WFS:', e);
        }
        
      } catch (error) {
        console.warn('Error fetching lookups:', error);
      }
      
      return lookups;
    }
    
    // --- DATA PROCESSING ---
    function processData(geojson, lookups = {companies: {}, facilityTypes: {}}) {
      const companies = {};
      
      if (!geojson.features || geojson.features.length === 0) {
        return { companies: {}, totalFacilities: 0 };
      }
      
      geojson.features.forEach(feature => {
        const props = feature.properties;
        
        // Get company name from facility_with_names view
        const companyName = props.company_name || 'Unknown Company';
        
        // Get facility type from facility_with_names view
        const facilityType = props.facility_type_name || 'Unknown Type';
        
        // Initialize company if not exists
        if (!companies[companyName]) {
          companies[companyName] = {};
        }
        
        // Initialize facility type if not exists
        if (!companies[companyName][facilityType]) {
          companies[companyName][facilityType] = [];
        }
        
        // Add facility
        companies[companyName][facilityType].push({
          name: props.name || 'Unnamed Facility',
          city: props.city || '',
          state: props.state || '',
          company: companyName,
          type: facilityType
        });
      });
      
      return {
        companies: companies,
        totalFacilities: geojson.features.length
      };
    }
    
    // Alternative processing: group by facility type only (fallback)
    function processDataByType(geojson, lookups = {companies: {}, facilityTypes: {}}) {
      const types = {};
      
      if (!geojson.features || geojson.features.length === 0) {
        return { companies: {}, totalFacilities: 0 };
      }
      
      geojson.features.forEach(feature => {
        const props = feature.properties;
        
        // Get facility type from facility_with_names view
        const facilityType = props.facility_type_name || 'Unknown Type';
        
        if (!types[facilityType]) {
          types[facilityType] = [];
        }
        
        types[facilityType].push({
          name: props.name || 'Unnamed Facility',
          city: props.city || '',
          state: props.state || '',
          type: facilityType
        });
      });
      
      // Convert to company-like structure for compatibility
      const companies = {
        'All Facilities': types
      };
      
      return {
        companies: companies,
        totalFacilities: geojson.features.length
      };
    }
    
    // --- BUILD HIERARCHY ---
    function buildHierarchy(data) {
      if (!data || !data.companies || Object.keys(data.companies).length === 0) {
        console.error('No company data to build hierarchy');
        throw new Error('No company data available');
      }
      
      const rootData = {
        name: "All Facilities",
        children: []
      };
      
      // Add companies
      Object.keys(data.companies).forEach(companyName => {
        const companyData = {
          name: companyName,
          children: []
        };
        
        // Add facility types
        Object.keys(data.companies[companyName]).forEach(facilityType => {
          const facilities = data.companies[companyName][facilityType];
          const typeData = {
            name: facilityType,
            children: facilities.map(f => ({
              name: f.name,
              value: 1,
              company: f.company,
              type: f.type,
              city: f.city,
              state: f.state
            }))
          };
          
          companyData.children.push(typeData);
        });
        
        rootData.children.push(companyData);
      });
      
      // Create hierarchy using d3.hierarchy
      root = d3.hierarchy(rootData)
        .sum(d => d.value || (d.children ? 0 : 1))
        .sort((a, b) => b.value - a.value);
      
      // Compute partition layout
      partition(root);
    }
    
    // --- RENDER CHART ---
    function renderChart() {
      if (!root) {
        console.error('No root data to render');
        return;
      }
      
      // Remove loading overlay
      d3.select("#chart-container").select(".loading-overlay").remove();
      
      // Ensure chart structure exists
      if (d3.select("#starburst").select("svg").empty()) {
        initializeChart();
      }
      
      // Clear existing content - explicitly remove paths and text
      g.selectAll("path").remove();
      g.selectAll("text").remove();
      
      // Get all nodes (excluding root)
      const nodes = root.descendants().filter(d => d.depth > 0);
      
      // Create color scale based on depth
      const colorScale = d3.scaleOrdinal()
        .domain(nodes.map(d => {
          if (d.depth === 1) return d.data.name; // Company level
          if (d.depth === 2) return d.parent.data.name + '_' + d.data.name; // Facility type level
          return d.parent.parent.data.name + '_' + d.parent.data.name + '_' + d.data.name;
        }))
        .range(d3.quantize(d3.interpolateRainbow, nodes.length));
      
      // Draw arcs
      const path = g.selectAll("path")
        .data(nodes)
        .enter()
        .append("path")
        .attr("fill", d => {
          if (d.depth === 1) {
            return colorSchemes.company(d.data.name);
          } else if (d.depth === 2) {
            return d3.color(colorSchemes.company(d.parent.data.name)).brighter(0.5);
          } else {
            return d3.color(colorSchemes.company(d.parent.parent.data.name)).brighter(1.2);
          }
        })
        .attr("stroke", "#fff")
        .attr("stroke-width", 1)
        .attr("d", arc)
        .style("cursor", "pointer")
        .on("mouseover", function(event, d) {
          showTooltip(event, d);
          highlightPath(d);
        })
        .on("mousemove", function(event) {
          moveTooltip(event);
        })
        .on("mouseout", function() {
          hideTooltip();
          resetHighlight();
        })
        .on("click", function(event, d) {
          zoomToNode(d);
        });
      
      // No text labels - all information shown only on hover
      
      // Update legend
      updateLegend(nodes);
      
      // Update info panel
      updateInfoPanel(data);
    }
    
    // --- INTERACTION FUNCTIONS ---
    function showTooltip(event, d) {
      const tooltip = d3.select("#tooltip");
      const value = d.value || d.children?.reduce((sum, c) => sum + (c.value || 0), 0) || 0;
      
      let content = `<strong>${d.data.name}</strong><br>`;
      
      if (d.depth === 1) {
        content += `Company<br>`;
        content += `Facilities: ${value}`;
      } else if (d.depth === 2) {
        content += `Type: ${d.data.name}<br>`;
        content += `Company: ${d.parent.data.name}<br>`;
        content += `Count: ${value}`;
      } else {
        content += `Facility: ${d.data.name}<br>`;
        if (d.data.city) content += `${d.data.city}, ${d.data.state || ''}<br>`;
        content += `Type: ${d.data.type}<br>`;
        content += `Company: ${d.data.company}`;
      }
      
      tooltip
        .html(content)
        .classed("visible", true);
    }
    
    function moveTooltip(event) {
      const tooltip = d3.select("#tooltip");
      tooltip
        .style("left", (event.pageX + 10) + "px")
        .style("top", (event.pageY - 10) + "px");
    }
    
    function hideTooltip() {
      d3.select("#tooltip").classed("visible", false);
    }
    
    function highlightPath(d) {
      // Highlight the path and its ancestors
      const pathToHighlight = [];
      let current = d;
      while (current) {
        pathToHighlight.push(current);
        current = current.parent;
      }
      
      g.selectAll("path")
        .style("opacity", p => pathToHighlight.includes(p) ? 1 : 0.3);
    }
    
    function resetHighlight() {
      g.selectAll("path").style("opacity", 1);
    }
    
    function zoomToNode(d) {
      // For now, just log the click
      // Could implement zoom/focus functionality here
      console.log('Clicked on:', d.data.name, d);
    }
    
    // --- UI UPDATE FUNCTIONS ---
    function updateLegend(nodes) {
      const companies = [...new Set(nodes.filter(d => d.depth === 1).map(d => d.data.name))];
      const legendContent = d3.select("#legend-content");
      legendContent.html("");
      
      companies.slice(0, 10).forEach(company => {
        const item = legendContent.append("div").attr("class", "legend-item");
        item.append("div")
          .attr("class", "legend-color")
          .style("background-color", colorSchemes.company(company));
        item.append("span").text(company);
      });
      
      if (companies.length > 10) {
        legendContent.append("div")
          .style("margin-top", "10px")
          .style("font-style", "italic")
          .text(`+ ${companies.length - 10} more companies`);
      }
    }
    
    function updateInfoPanel(data) {
      const infoContent = d3.select("#info-content");
      const companyCount = Object.keys(data.companies).length;
      const totalFacilities = data.totalFacilities;
      
      let html = `<strong>Total Facilities:</strong> ${totalFacilities}<br>`;
      html += `<strong>Companies:</strong> ${companyCount}<br><br>`;
      html += `<small>Hover over segments for details</small>`;
      
      infoContent.html(html);
    }
    
    function showLoading() {
      // Don't remove the chart structure, just show loading overlay
      const container = d3.select("#chart-container");
      const existing = container.select(".loading-overlay");
      if (existing.empty()) {
        container.append("div")
          .attr("class", "loading-overlay")
          .style("position", "absolute")
          .style("top", "50%")
          .style("left", "50%")
          .style("transform", "translate(-50%, -50%)")
          .style("z-index", "10000")
          .style("background", "rgba(255,255,255,0.9)")
          .style("padding", "20px")
          .style("border-radius", "8px")
          .text("Loading facilities data...");
      }
    }
    
    function showError(message) {
      // Remove loading overlay
      d3.select("#chart-container").select(".loading-overlay").remove();
      
      const container = d3.select("#chart-container");
      const existing = container.select(".error-overlay");
      if (existing.empty()) {
        container.append("div")
          .attr("class", "error-overlay")
          .style("position", "absolute")
          .style("top", "50%")
          .style("left", "50%")
          .style("transform", "translate(-50%, -50%)")
          .style("z-index", "10000")
          .style("background", "rgba(255,255,255,0.95)")
          .style("padding", "20px")
          .style("border-radius", "8px")
          .style("color", "#d32f2f")
          .html(`<strong>Error loading data</strong><br>${message}<br><small>Check console for details</small>`);
      } else {
        existing.html(`<strong>Error loading data</strong><br>${message}<br><small>Check console for details</small>`);
      }
    }
    
    // --- FILTER FUNCTIONS ---
    function populateCompanyFilter(data) {
      const companyList = document.getElementById('company-list');
      const companies = Object.keys(data.companies).sort();
      
      // Clear existing list
      companyList.innerHTML = '';
      
      // Add each company as a checkbox
      companies.forEach(company => {
        const item = document.createElement('div');
        item.className = 'company-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `company-${company.replace(/\s+/g, '-')}`;
        checkbox.value = company;
        checkbox.checked = true; // All selected by default
        
        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.textContent = company;
        
        item.appendChild(checkbox);
        item.appendChild(label);
        companyList.appendChild(item);
      });
      
      // Initialize selected companies set with all companies
      selectedCompanies = new Set(companies);
    }
    
    function setupFilterListeners() {
      const filterControl = document.getElementById('filter-control');
      const filterHeader = document.getElementById('filter-header');
      const selectAllCheckbox = document.getElementById('select-all-companies');
      const companyList = document.getElementById('company-list');
      
      // Toggle dropdown on header click
      filterHeader.addEventListener('click', function(e) {
        filterControl.classList.toggle('expanded');
      });
      
      // Keep dropdown open when clicking inside it
      const filterDropdown = document.getElementById('filter-dropdown');
      filterDropdown.addEventListener('click', function(e) {
        e.stopPropagation();
      });
      
      // Close dropdown when clicking outside (optional - hover will handle it)
      document.addEventListener('click', function(e) {
        if (!filterControl.contains(e.target)) {
          filterControl.classList.remove('expanded');
        }
      });
      
      // Select All checkbox
      selectAllCheckbox.addEventListener('change', function(e) {
        const checkboxes = companyList.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(cb => {
          cb.checked = e.target.checked;
        });
        
        if (e.target.checked) {
          selectedCompanies = new Set(Array.from(checkboxes).map(cb => cb.value));
        } else {
          selectedCompanies.clear();
        }
        
        applyFilter(selectedCompanies);
      });
      
      // Individual company checkboxes
      companyList.addEventListener('change', function(e) {
        if (e.target.type === 'checkbox') {
          const company = e.target.value;
          
          if (e.target.checked) {
            selectedCompanies.add(company);
          } else {
            selectedCompanies.delete(company);
          }
          
          // Update "Select All" checkbox state
          const allCheckboxes = Array.from(companyList.querySelectorAll('input[type="checkbox"]'));
          const allChecked = allCheckboxes.every(cb => cb.checked);
          const noneChecked = allCheckboxes.every(cb => !cb.checked);
          selectAllCheckbox.checked = allChecked;
          selectAllCheckbox.indeterminate = !allChecked && !noneChecked;
          
          applyFilter(selectedCompanies);
        }
      });
    }
    
    function applyFilter(companySet) {
      if (!allData) {
        console.error('No data available to filter');
        return;
      }
      
      // If no companies selected, show empty chart
      if (!companySet || companySet.size === 0) {
        data = {
          companies: {},
          totalFacilities: 0
        };
      } else if (companySet.size === Object.keys(allData.companies).length) {
        // All companies selected, use all data
        data = allData;
      } else {
        // Filter to only selected companies
        const filteredCompanies = {};
        let totalFacilities = 0;
        
        companySet.forEach(companyName => {
          if (allData.companies[companyName]) {
            filteredCompanies[companyName] = allData.companies[companyName];
            totalFacilities += Object.values(allData.companies[companyName])
              .reduce((sum, types) => sum + types.length, 0);
          }
        });
        
        data = {
          companies: filteredCompanies,
          totalFacilities: totalFacilities
        };
      }
      
      // Rebuild hierarchy and render with filtered data
      buildHierarchy(data);
      renderChart();
    }
  </script>
</body>
</html>

